name: Deploy to AWS

on:
  pull_request:
    branches: [ main ]
    types: [closed]
  push:
    branches: [ main ]
  workflow_dispatch:  # Permite execução manual da pipeline

permissions:
  id-token: write
  contents: read

env:
  ECR_REPOSITORY: pointtils
  APP_IMAGE_TAG: latest
  DB_IMAGE_TAG: latest

jobs:
  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      with:
        mask-password: 'true'

    - name: Check if ECR repository exists and create if needed
      run: |
        # Verificar e criar repositório da aplicação
        exists=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} 2>/dev/null || echo "false")
        if [ "$exists" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }} already exists"
        fi
        
        # Verificar e criar repositório do banco de dados
        exists_db=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }}-db 2>/dev/null || echo "false")
        if [ "$exists_db" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}-db"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}-db --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }}-db already exists"
        fi

    - name: Build and push images with docker compose
      id: build-images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        SPRING_DATASOURCE_URL: jdbc:postgresql://pointtils-db:5432/${{ secrets.DB_NAME || 'pointtils-db' }}
        SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
        SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
        SPRING_APPLICATION_NAME: pointtils
        SERVER_PORT: 8080
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        JWT_EXPIRATION_TIME: 3600000
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SPRING_JPA_SHOW_SQL: false
        SPRINGDOC_API_DOCS_ENABLED: true
        SPRINGDOC_SWAGGER_UI_ENABLED: true
        SPRINGDOC_SWAGGER_UI_PATH: /swagger-ui.html
        CLOUD_AWS_BUCKET_NAME: ${{ secrets.CLOUD_AWS_BUCKET_NAME }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        POSTGRES_DB: ${{ secrets.DB_NAME || 'pointtils-db' }}
        POSTGRES_USER: ${{ secrets.DB_USERNAME }}
        POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
      run: |
        # Construir imagens usando docker-compose.prod.yaml
        docker compose -f docker-compose.prod.yaml build
        
        # Tag e push da imagem da aplicação (com senha mascarada)
        echo "Tagging and pushing application image..."
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        echo "app_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        # Tag e push da imagem do banco de dados (com senha mascarada)
        echo "Tagging and pushing database image..."
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        echo "db_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-push-images
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Create SSH key file
      run: |
        mkdir -p ./terraform
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ./terraform/pointtils_key.pub

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: '1.5.0'
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    - name: Create terraform.tfvars file
      run: |
        cat > terraform/terraform.tfvars << EOF
        aws_region     = "${{ secrets.AWS_REGION }}"
        db_username    = "${{ secrets.DB_USERNAME }}"
        db_password    = "${{ secrets.DB_PASSWORD }}"
        db_name        = "${{ secrets.DB_NAME || 'pointtils-db' }}"
        jwt_secret     = "${{ secrets.JWT_SECRET }}"
        app_image      = "${{ needs.build-and-push-images.outputs.app_image }}"
        db_image       = "${{ needs.build-and-push-images.outputs.db_image }}"
        EOF

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: terraform
      id: terraform-apply
      continue-on-error: true
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform outputs
      working-directory: terraform
      id: terraform-outputs
      run: |
        echo "=== Obtendo IP da instância EC2 ==="
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pointtils-app" --query 'Reservations[*].Instances[*].InstanceId' --output text)
        
        if [ -n "$INSTANCE_ID" ]; then
          echo "Instance ID encontrado: $INSTANCE_ID"
          
          # Buscar Elastic IP associado
          INSTANCE_IP=$(aws ec2 describe-addresses --filters "Name=instance-id,Values=$INSTANCE_ID" --query 'Addresses[0].PublicIp' --output text || echo "")
          
          # Se não tem Elastic IP, usar o IP público da instância
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Elastic IP não encontrado, usando IP público direto da instância"
            INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text || echo "")
          fi
          
          # Limpar o IP (remover aspas e espaços)
          CLEAN_IP=$(echo "$INSTANCE_IP" | tr -d '"' | tr -d ' ')
          echo "IP encontrado: $CLEAN_IP"
          
          # Verificar se o IP tem formato válido
          if [[ "$CLEAN_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "IP válido: $CLEAN_IP"
            echo "app_ip=$CLEAN_IP" >> $GITHUB_OUTPUT
          else
            echo "AVISO: Formato de IP inválido ($CLEAN_IP), usando placeholder"
            echo "app_ip=127.0.0.1" >> $GITHUB_OUTPUT
          fi
        else
          echo "Nenhuma instância encontrada, usando IP placeholder"
          echo "app_ip=127.0.0.1" >> $GITHUB_OUTPUT
        fi
        
        echo "ecr_repo=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}" >> $GITHUB_OUTPUT

    - name: Verify EC2 host availability
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        
        if [ "$HOST_IP" = "127.0.0.1" ]; then
          echo "Usando IP placeholder (127.0.0.1), pulando verificação de SSH"
          echo "HOST_READY=false" >> $GITHUB_ENV
          exit 0
        fi
        
        echo "Verificando disponibilidade do host: $HOST_IP"
        # Instalar netcat se necessário
        sudo apt-get update -y && sudo apt-get install -y netcat-openbsd
        # Aguardar um tempo para garantir que a instância esteja pronta
        echo "Aguardando 60 segundos para inicialização da instância..."
        sleep 60
        
        # Tentar conectar várias vezes com um timeout
        for i in {1..12}; do
          if nc -z -v -w5 $HOST_IP 22; then
            echo "Host disponível para SSH"
            echo "HOST_READY=true" >> $GITHUB_ENV
            break
          else
            echo "Tentativa $i: SSH ainda não disponível. Aguardando..."
            sleep 15
          fi
          
          if [ $i -eq 12 ]; then
            echo "AVISO: Host não respondeu após 12 tentativas, mas vamos continuar mesmo assim"
            echo "HOST_READY=false" >> $GITHUB_ENV
          fi
        done

    - name: Health check application
      if: steps.terraform-outputs.outputs.app_ip != '127.0.0.1' && env.HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        echo "Realizando health check na aplicação: http://$HOST_IP:8080/actuator/health"
        
        # Aguardar aplicação inicializar
        sleep 30
        
        for i in {1..10}; do
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST_IP:8080/actuator/health || echo "000")
          if [ "$RESPONSE" = "200" ]; then
            echo "✅ Aplicação respondendo corretamente (HTTP 200)"
            break
          else
            echo "Tentativa $i: Aplicação não respondeu (HTTP $RESPONSE). Aguardando..."
            sleep 15
          fi
        done

    - name: Deployment Summary
      run: |
        echo "======================================"
        if [ "${{ env.HOST_READY }}" == "true" ]; then
          echo "✅ Deployment completed successfully!"
        elif [ "${{ steps.terraform-outputs.outputs.app_ip }}" == "127.0.0.1" ]; then
          echo "⚠️ Infrastructure deployment incomplete - could not retrieve valid IP"
        else
          echo "⚠️ Deployment may have issues - host was not ready for SSH"
        fi
        echo "======================================"
        
        if [ "${{ steps.terraform-outputs.outputs.app_ip }}" != "127.0.0.1" ]; then
          echo "Application URL: http://${{ steps.terraform-outputs.outputs.app_ip }}:8080"
          echo "Swagger UI: http://${{ steps.terraform-outputs.outputs.app_ip }}:8080/swagger-ui.html"
          echo "SSH Access: ssh ubuntu@${{ steps.terraform-outputs.outputs.app_ip }}"
        else
          echo "Application URL: Not available (deployment incomplete)"
          echo "SSH Access: Not available (deployment incomplete)"
        fi
        
        echo "ECR Repository: ${{ steps.terraform-outputs.outputs.ecr_repo }}"
        echo "======================================"
