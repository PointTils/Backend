name: Deploy to AWS

on:
  pull_request:
    branches: [ main ]
    types: [closed]
  push:
    branches: [ main ]
  workflow_dispatch:  # Permite execu√ß√£o manual da pipeline

permissions:
  id-token: write
  contents: read

env:
  ECR_REPOSITORY: pointtils
  APP_IMAGE_TAG: latest
  DB_IMAGE_TAG: latest

jobs:
  quality-assurance:
    name: Quality Assurance
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    - name: Run unit tests
      run: mvn clean test
      working-directory: ./pointtils

    - name: Build with Maven
      run: mvn clean package -DskipTests
      working-directory: ./pointtils

  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: quality-assurance
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      with:
        mask-password: 'true'

    - name: Check if ECR repository exists and create if needed
      run: |
        # Verificar e criar reposit√≥rio da aplica√ß√£o
        exists=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} 2>/dev/null || echo "false")
        if [ "$exists" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }} already exists"
        fi
        
        # Verificar e criar reposit√≥rio do banco de dados
        exists_db=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }}-db 2>/dev/null || echo "false")
        if [ "$exists_db" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}-db"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}-db --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }}-db already exists"
        fi

    - name: Build and push images with docker compose
      id: build-images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        SPRING_DATASOURCE_URL: jdbc:postgresql://pointtils-db:5432/${{ secrets.DB_NAME || 'pointtils-db' }}
        SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
        SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
        SPRING_APPLICATION_NAME: pointtils
        SERVER_PORT: 8080
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        JWT_EXPIRATION_TIME: 3600000
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SPRING_JPA_SHOW_SQL: false
        SPRINGDOC_API_DOCS_ENABLED: true
        SPRINGDOC_SWAGGER_UI_ENABLED: true
        SPRINGDOC_SWAGGER_UI_PATH: /swagger-ui.html
        CLOUD_AWS_BUCKET_NAME: ${{ secrets.CLOUD_AWS_BUCKET_NAME }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        POSTGRES_DB: ${{ secrets.DB_NAME || 'pointtils-db' }}
        POSTGRES_USER: ${{ secrets.DB_USERNAME }}
        POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
      run: |
        # Construir imagens usando docker-compose.prod.yaml
        docker compose -f docker-compose.prod.yaml build
        
        # Tag e push da imagem da aplica√ß√£o (com senha mascarada)
        echo "Tagging and pushing application image..."
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        echo "app_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        # Tag e push da imagem do banco de dados (com senha mascarada)
        echo "Tagging and pushing database image..."
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        echo "db_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-push-images
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Create SSH key file
      run: |
        mkdir -p ./terraform
        # Criar chave SSH privada
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ./terraform/pointtils_key
        # Corrigir permiss√µes da chave SSH
        chmod 600 ./terraform/pointtils_key
        # Criar chave SSH p√∫blica
        echo "${{ secrets.SSH_PUBLIC_KEY }}" > ./terraform/pointtils_key.pub

    - name: Create Terraform backend resources
      run: |
        echo "Criando recursos de backend para Terraform de produ√ß√£o..."
        chmod +x terraform/create-backend.sh
        ./terraform/create-backend.sh "${{ secrets.AWS_REGION }}"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: '1.5.0'
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    - name: Create terraform.tfvars file
      run: |
        cat > terraform/terraform.tfvars << 'EOF'
        aws_region     = "${{ secrets.AWS_REGION }}"
        db_username    = "${{ secrets.DB_USERNAME }}"
        db_password    = "${{ secrets.DB_PASSWORD }}"
        db_name        = "${{ secrets.DB_NAME || 'pointtils-db' }}"
        jwt_secret     = "${{ secrets.JWT_SECRET }}"
        app_image      = "${{ needs.build-and-push-images.outputs.app_image }}"
        db_image       = "${{ needs.build-and-push-images.outputs.db_image }}"
        EOF

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: terraform
      id: terraform-apply
      continue-on-error: true
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform outputs
      working-directory: terraform
      id: terraform-outputs
      run: |
        echo "=== Obtendo IP da inst√¢ncia EC2 ==="
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pointtils-app" --query 'Reservations[*].Instances[*].InstanceId' --output text)
        
        if [ -n "$INSTANCE_ID" ]; then
          echo "Instance ID encontrado: $INSTANCE_ID"
          
          # Buscar Elastic IP associado
          INSTANCE_IP=$(aws ec2 describe-addresses --filters "Name=instance-id,Values=$INSTANCE_ID" --query 'Addresses[0].PublicIp' --output text || echo "")
          
          # Se n√£o tem Elastic IP, usar o IP p√∫blico da inst√¢ncia
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Elastic IP n√£o encontrado, usando IP p√∫blico direto da inst√¢ncia"
            INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text || echo "")
          fi
          
          # Limpar o IP (remover aspas e espa√ßos)
          CLEAN_IP=$(echo "$INSTANCE_IP" | tr -d '"' | tr -d ' ')
          echo "IP encontrado: $CLEAN_IP"
          
          # Verificar se o IP tem formato v√°lido
          if [[ "$CLEAN_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "IP v√°lido: $CLEAN_IP"
            echo "app_ip=$CLEAN_IP" >> $GITHUB_OUTPUT
          else
            echo "AVISO: Formato de IP inv√°lido ($CLEAN_IP), usando placeholder"
            echo "app_ip=127.0.0.1" >> $GITHUB_OUTPUT
          fi
        else
          echo "Nenhuma inst√¢ncia encontrada, usando IP placeholder"
          echo "app_ip=127.0.0.1" >> $GITHUB_OUTPUT
        fi
        
        echo "ecr_repo=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}" >> $GITHUB_OUTPUT

    - name: Verify EC2 host availability
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        
        if [ "$HOST_IP" = "127.0.0.1" ]; then
          echo "Usando IP placeholder (127.0.0.1), pulando verifica√ß√£o de SSH"
          echo "HOST_READY=false" >> $GITHUB_ENV
          exit 0
        fi
        
        echo "Verificando disponibilidade do host: $HOST_IP"
        # Instalar netcat se necess√°rio
        sudo apt-get update -y && sudo apt-get install -y netcat-openbsd
        # Aguardar um tempo para garantir que a inst√¢ncia esteja pronta
        echo "Aguardando 60 segundos para inicializa√ß√£o da inst√¢ncia..."
        sleep 60
        
        # Tentar conectar v√°rias vezes com um timeout
        for i in {1..12}; do
          if nc -z -v -w5 $HOST_IP 22; then
            echo "Host dispon√≠vel para SSH"
            echo "HOST_READY=true" >> $GITHUB_ENV
            break
          else
            echo "Tentativa $i: SSH ainda n√£o dispon√≠vel. Aguardando..."
            sleep 15
          fi
          
          if [ $i -eq 12 ]; then
            echo "AVISO: Host n√£o respondeu ap√≥s 12 tentativas, mas vamos continuar mesmo assim"
            echo "HOST_READY=false" >> $GITHUB_ENV
          fi
        done

    - name: Deploy latest images to EC2
      if: steps.terraform-outputs.outputs.app_ip != '127.0.0.1' && env.HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        echo "Executando deploy das imagens mais recentes na EC2: $HOST_IP"
        
        # Copiar script de deploy para a EC2
        echo "Copiando script de deploy para a EC2..."
        scp -o StrictHostKeyChecking=no -i ./terraform/pointtils_key terraform/deploy-app.sh ubuntu@$HOST_IP:/home/ubuntu/
        
        # Executar script de deploy na EC2 com par√¢metros
        echo "Executando script de deploy com par√¢metros..."
        ssh -o StrictHostKeyChecking=no -i ./terraform/pointtils_key ubuntu@$HOST_IP "chmod +x /home/ubuntu/deploy-app.sh && /home/ubuntu/deploy-app.sh \
          '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
          '${{ secrets.DB_USERNAME }}' \
          '${{ secrets.DB_PASSWORD }}' \
          '${{ secrets.DB_NAME || 'pointtils-db' }}' \
          '${{ secrets.JWT_SECRET }}' \
          '${{ secrets.AWS_REGION }}' \
          '${{ secrets.CLOUD_AWS_BUCKET_NAME }}' \
          '${{ secrets.AWS_ACCESS_KEY_ID }}' \
          '${{ secrets.AWS_SECRET_ACCESS_KEY }}'"
        
        echo "‚úÖ Deploy das imagens mais recentes conclu√≠do com sucesso!"

    - name: Health check application
      if: steps.terraform-outputs.outputs.app_ip != '127.0.0.1' && env.HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        echo "Realizando health check final na aplica√ß√£o: http://$HOST_IP:8080/actuator/health"
        
        # Aguardar aplica√ß√£o inicializar ap√≥s deploy
        sleep 30
        
        for i in {1..10}; do
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST_IP:8080/actuator/health || echo "000")
          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Aplica√ß√£o respondendo corretamente (HTTP 200)"
            break
          else
            echo "Tentativa $i: Aplica√ß√£o n√£o respondeu (HTTP $RESPONSE). Aguardando..."
            sleep 15
          fi
        done

    - name: Rollback on failure (Production)
      if: failure() && steps.terraform-outputs.outputs.app_ip != '127.0.0.1' && env.HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.app_ip }}"
        echo "üö® Deploy de produ√ß√£o falhou! Iniciando rollback autom√°tico..."
        
        # Copiar script de rollback para a EC2 de produ√ß√£o
        scp -o StrictHostKeyChecking=no -i ./terraform/pointtils_key terraform/rollback-app.sh ubuntu@$HOST_IP:/home/ubuntu/
        
        # Executar rollback na EC2 de produ√ß√£o
        ssh -o StrictHostKeyChecking=no -i ./terraform/pointtils_key ubuntu@$HOST_IP "chmod +x /home/ubuntu/rollback-app.sh && /home/ubuntu/rollback-app.sh \
          '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
          '${{ secrets.DB_USERNAME }}' \
          '${{ secrets.DB_PASSWORD }}' \
          '${{ secrets.DB_NAME || 'pointtils-db' }}' \
          '${{ secrets.JWT_SECRET }}' \
          '${{ secrets.AWS_REGION }}' \
          '${{ secrets.CLOUD_AWS_BUCKET_NAME }}' \
          '${{ secrets.AWS_ACCESS_KEY_ID }}' \
          '${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
          'previous'"
        
        echo "‚ö†Ô∏è Rollback executado. Verifique o status da aplica√ß√£o de produ√ß√£o manualmente."

    - name: Deployment Summary
      run: |
        echo "======================================"
        if [ "${{ env.HOST_READY }}" == "true" ]; then
          echo "‚úÖ Deployment completed successfully!"
        elif [ "${{ steps.terraform-outputs.outputs.app_ip }}" == "127.0.0.1" ]; then
          echo "‚ö†Ô∏è Infrastructure deployment incomplete - could not retrieve valid IP"
        else
          echo "‚ö†Ô∏è Deployment may have issues - host was not ready for SSH"
        fi
        echo "======================================"
        
        if [ "${{ steps.terraform-outputs.outputs.app_ip }}" != "127.0.0.1" ]; then
          echo "Application URL: http://${{ steps.terraform-outputs.outputs.app_ip }}:8080"
          echo "Swagger UI: http://${{ steps.terraform-outputs.outputs.app_ip }}:8080/swagger-ui.html"
          echo "SSH Access: ssh ubuntu@${{ steps.terraform-outputs.outputs.app_ip }}"
        else
          echo "Application URL: Not available (deployment incomplete)"
          echo "SSH Access: Not available (deployment incomplete)"
        fi
        
        echo "ECR Repository: ${{ steps.terraform-outputs.outputs.ecr_repo }}"
        echo "======================================"
