name: Deploy to Development

on:
  push:
    branches: [ dev_v1, feature/* ]
  pull_request:
    branches: [ dev_v1 ]
    types: [closed]
  workflow_dispatch:  # Permite execução manual da pipeline

permissions:
  id-token: write
  contents: read

env:
  ECR_REPOSITORY: pointtils
  APP_IMAGE_TAG: dev-latest
  DB_IMAGE_TAG: dev-latest
  ENVIRONMENT: development
 

jobs:
  build-and-test:
    name: Build, Test and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    - name: Run unit tests
      run: mvn clean test
      working-directory: ./pointtils

    - name: Build with Maven
      run: mvn clean package -DskipTests
      working-directory: ./pointtils

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      with:
        mask-password: 'true'

    - name: Check if ECR repository exists and create if needed
      run: |
        # Verificar e criar repositório da aplicação
        exists=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} 2>/dev/null || echo "false")
        if [ "$exists" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }} already exists"
        fi
        
        # Verificar e criar repositório do banco de dados
        exists_db=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }}-db 2>/dev/null || echo "false")
        if [ "$exists_db" = "false" ]; then
          echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}-db"
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}-db --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
        else
          echo "ECR repository ${{ env.ECR_REPOSITORY }}-db already exists"
        fi

    - name: Build and push images with docker compose
      id: build-images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: dev-${{ github.sha }}
        SPRING_DATASOURCE_URL: jdbc:postgresql://pointtils-db:5432/${{ secrets.DB_NAME || 'pointtils-db' }}
        SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
        SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
        SPRING_APPLICATION_NAME: pointtils-dev
        SERVER_PORT: 8080
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        JWT_EXPIRATION_TIME: 3600000
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SPRING_JPA_SHOW_SQL: false
        SPRINGDOC_API_DOCS_ENABLED: true
        SPRINGDOC_SWAGGER_UI_ENABLED: true
        SPRINGDOC_SWAGGER_UI_PATH: /swagger-ui.html
        CLOUD_AWS_BUCKET_NAME: ${{ secrets.CLOUD_AWS_BUCKET_NAME }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        POSTGRES_DB: ${{ secrets.DB_NAME || 'pointtils-db' }}
        POSTGRES_USER: ${{ secrets.DB_USERNAME }}
        POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
      run: |
        # Construir imagens usando docker-compose.prod.yaml
        docker compose -f docker-compose.prod.yaml build
        
        # Tag e push da imagem da aplicação (com senha mascarada)
        echo "Tagging and pushing application image..."
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker tag pointtils $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
        echo "app_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        # Tag e push da imagem do banco de dados (com senha mascarada)
        echo "Tagging and pushing database image..."
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker tag pointtils-db $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
        echo "db_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-dev-infrastructure:
    name: Deploy Development Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Create SSH key file for development
      run: |
        mkdir -p ./terraform-dev
        # Criar chave SSH privada para desenvolvimento
        echo "${{ secrets.SSH_DEV_PRIVATE_KEY }}" > ./terraform-dev/pointtils_dev_key
        # Corrigir permissões da chave SSH
        chmod 600 ./terraform-dev/pointtils_dev_key
        # Criar chave SSH pública para desenvolvimento
        echo "${{ secrets.SSH_DEV_PUBLIC_KEY }}" > ./terraform-dev/pointtils_dev_key.pub

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: '1.5.0'
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    - name: Create terraform.tfvars file for development
      run: |
        cat > terraform-dev/terraform.tfvars << 'EOF'
        aws_region     = "${{ secrets.AWS_REGION }}"
        db_username    = "${{ secrets.DB_DEV_USERNAME || 'pointtilsdevadmin' }}"
        db_password    = "${{ secrets.DB_DEV_PASSWORD || 'devpassword123' }}"
        db_name        = "${{ secrets.DB_DEV_NAME || 'pointtils-dev-db' }}"
        jwt_secret     = "${{ secrets.JWT_DEV_SECRET || 'devjwtsecretkey1234567890123456789012345678901234' }}"
        app_image      = "${{ needs.build-and-test.outputs.app_image }}"
        db_image       = "${{ needs.build-and-test.outputs.db_image }}"
        EOF

    - name: Create Terraform backend resources
      run: |
        echo "Criando recursos de backend para Terraform..."
        chmod +x terraform-dev/create-backend.sh
        ./terraform-dev/create-backend.sh "${{ secrets.AWS_REGION }}"

    - name: Terraform Init (Development)
      working-directory: terraform-dev
      run: terraform init

    - name: Terraform Validate (Development)
      working-directory: terraform-dev
      run: terraform validate

    - name: Terraform Plan (Development)
      working-directory: terraform-dev
      run: terraform plan -out=tfplan

    - name: Terraform Apply (Development)
      working-directory: terraform-dev
      id: terraform-apply
      continue-on-error: true
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform outputs (Development)
      working-directory: terraform-dev
      id: terraform-outputs
      run: |
        echo "=== Obtendo IP da instância EC2 de desenvolvimento ==="
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pointtils-dev-app" --query 'Reservations[*].Instances[*].InstanceId' --output text)
        
        if [ -n "$INSTANCE_ID" ]; then
          echo "Instance ID encontrado: $INSTANCE_ID"
          
          # Buscar Elastic IP associado
          INSTANCE_IP=$(aws ec2 describe-addresses --filters "Name=instance-id,Values=$INSTANCE_ID" --query 'Addresses[0].PublicIp' --output text || echo "")
          
          # Se não tem Elastic IP, usar o IP público da instância
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
            echo "Elastic IP não encontrado, usando IP público direto da instância"
            INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text || echo "")
          fi
          
          # Limpar o IP (remover aspas e espaços)
          CLEAN_IP=$(echo "$INSTANCE_IP" | tr -d '"' | tr -d ' ')
          echo "IP encontrado: $CLEAN_IP"
          
          # Verificar se o IP tem formato válido
          if [[ "$CLEAN_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "IP válido: $CLEAN_IP"
            echo "dev_app_ip=$CLEAN_IP" >> $GITHUB_OUTPUT
          else
            echo "AVISO: Formato de IP inválido ($CLEAN_IP), usando placeholder"
            echo "dev_app_ip=127.0.0.1" >> $GITHUB_OUTPUT
          fi
        else
          echo "Nenhuma instância de desenvolvimento encontrada, usando IP placeholder"
          echo "dev_app_ip=127.0.0.1" >> $GITHUB_OUTPUT
        fi
        
        echo "dev_ecr_repo=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}" >> $GITHUB_OUTPUT

    - name: Verify EC2 host availability (Development)
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
        
        if [ "$HOST_IP" = "127.0.0.1" ]; then
          echo "Usando IP placeholder (127.0.0.1), pulando verificação de SSH"
          echo "DEV_HOST_READY=false" >> $GITHUB_ENV
          exit 0
        fi
        
        echo "Verificando disponibilidade do host de desenvolvimento: $HOST_IP"
        # Instalar netcat se necessário
        sudo apt-get update -y && sudo apt-get install -y netcat-openbsd
        # Aguardar um tempo para garantir que a instância esteja pronta
        echo "Aguardando 60 segundos para inicialização da instância de desenvolvimento..."
        sleep 60
        
        # Tentar conectar várias vezes com um timeout
        for i in {1..12}; do
          if nc -z -v -w5 $HOST_IP 22; then
            echo "Host de desenvolvimento disponível para SSH"
            echo "DEV_HOST_READY=true" >> $GITHUB_ENV
            break
          else
            echo "Tentativa $i: SSH ainda não disponível. Aguardando..."
            sleep 15
          fi
          
          if [ $i -eq 12 ]; then
            echo "AVISO: Host de desenvolvimento não respondeu após 12 tentativas, mas vamos continuar mesmo assim"
            echo "DEV_HOST_READY=false" >> $GITHUB_ENV
          fi
        done

    - name: Deploy latest images to Development EC2
      if: steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
        echo "Executando deploy das imagens mais recentes na EC2 de desenvolvimento: $HOST_IP"
        
        # Copiar script de deploy ESPECÍFICO para desenvolvimento
        echo "Copiando script de deploy ESPECÍFICO para desenvolvimento..."
        scp -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils_dev_key terraform-dev/deploy-dev-app.sh ubuntu@$HOST_IP:/home/ubuntu/
        
        # Executar script de deploy ESPECÍFICO para desenvolvimento
        echo "Executando script de deploy ESPECÍFICO para desenvolvimento..."
        ssh -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils_dev_key ubuntu@$HOST_IP "chmod +x /home/ubuntu/deploy-dev-app.sh && /home/ubuntu/deploy-dev-app.sh \
          '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
          '${{ secrets.DB_DEV_USERNAME || 'pointtilsdevadmin' }}' \
          '${{ secrets.DB_DEV_PASSWORD || 'devpassword123' }}' \
          '${{ secrets.DB_DEV_NAME || 'pointtils-dev-db' }}' \
          '${{ secrets.JWT_DEV_SECRET || 'devjwtsecretkey1234567890123456789012345678901234' }}' \
          '${{ secrets.AWS_REGION }}' \
          '${{ secrets.CLOUD_AWS_BUCKET_NAME }}' \
          '${{ secrets.AWS_ACCESS_KEY_ID }}' \
          '${{ secrets.AWS_SECRET_ACCESS_KEY }}'"
        
        echo "✅ Deploy das imagens mais recentes para desenvolvimento concluído com sucesso!"

    - name: Health check development application
      if: steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
        echo "Realizando health check final na aplicação de desenvolvimento: http://$HOST_IP:8080/actuator/health"
        
        # Aguardar aplicação inicializar após deploy
        sleep 30
        
        for i in {1..10}; do
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST_IP:8080/actuator/health || echo "000")
          if [ "$RESPONSE" = "200" ]; then
            echo "✅ Aplicação de desenvolvimento respondendo corretamente (HTTP 200)"
            break
          else
            echo "Tentativa $i: Aplicação de desenvolvimento não respondeu (HTTP $RESPONSE). Aguardando..."
            sleep 15
          fi
        done

    - name: Rollback on failure (Development)
      if: failure() && steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
      run: |
        HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
        echo "🚨 Deploy de desenvolvimento falhou! Iniciando rollback automático..."
        
        # Copiar script de rollback ESPECÍFICO para desenvolvimento
        scp -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils_dev_key terraform-dev/rollback-dev-app.sh ubuntu@$HOST_IP:/home/ubuntu/
        
        # Executar rollback ESPECÍFICO para desenvolvimento
        ssh -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils_dev_key ubuntu@$HOST_IP "chmod +x /home/ubuntu/rollback-dev-app.sh && /home/ubuntu/rollback-dev-app.sh \
          '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
          '${{ secrets.DB_DEV_USERNAME || 'pointtilsdevadmin' }}' \
          '${{ secrets.DB_DEV_PASSWORD || 'devpassword123' }}' \
          '${{ secrets.DB_DEV_NAME || 'pointtils-dev-db' }}' \
          '${{ secrets.JWT_DEV_SECRET || 'devjwtsecretkey1234567890123456789012345678901234' }}' \
          '${{ secrets.AWS_REGION }}' \
          '${{ secrets.CLOUD_AWS_BUCKET_NAME }}' \
          '${{ secrets.AWS_ACCESS_KEY_ID }}' \
          '${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
          'previous'"
        
        echo "⚠️ Rollback de DESENVOLVIMENTO executado. Verifique o status da aplicação de desenvolvimento manualmente."

    - name: Development Deployment Summary
      run: |
        echo "======================================"
        if [ "${{ env.DEV_HOST_READY }}" == "true" ]; then
          echo "✅ Development deployment completed successfully!"
        elif [ "${{ steps.terraform-outputs.outputs.dev_app_ip }}" == "127.0.0.1" ]; then
          echo "⚠️ Development infrastructure deployment incomplete - could not retrieve valid IP"
        else
          echo "⚠️ Development deployment may have issues - host was not ready for SSH"
        fi
        echo "======================================"
        
        if [ "${{ steps.terraform-outputs.outputs.dev_app_ip }}" != "127.0.0.1" ]; then
          echo "Development Application URL: http://${{ steps.terraform-outputs.outputs.dev_app_ip }}:8080"
          echo "Development Swagger UI: http://${{ steps.terraform-outputs.outputs.dev_app_ip }}:8080/swagger-ui.html"
          echo "Development SSH Access: ssh ubuntu@${{ steps.terraform-outputs.outputs.dev_app_ip }}"
        else
          echo "Development Application URL: Not available (deployment incomplete)"
          echo "Development SSH Access: Not available (deployment incomplete)"
        fi
        
        echo "Development ECR Repository: ${{ steps.terraform-outputs.outputs.dev_ecr_repo }}"
        echo "======================================"
