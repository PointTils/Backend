name: Deploy to Development

on:
  push:
    branches: [ dev_v1, feature/* ]
  pull_request:
    branches: [ dev_v1 ]
    types: [closed]
  workflow_dispatch:  # Permite execu√ß√£o manual da pipeline via GitHub

permissions:
  id-token: write
  contents: read

env:
  ECR_REPOSITORY: pointtils-dev
  APP_IMAGE: backend-pointtils-dev
  DB_IMAGE: backend-pointtils-db-dev
  APP_IMAGE_TAG: dev-latest
  DB_IMAGE_TAG: dev-latest
  ENVIRONMENT: development

jobs:
  build-and-test:
    name: Build, Test and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Run unit tests
        run: mvn clean test
        working-directory: ./pointtils

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: 'true'

      - name: Check if ECR repository exists and create if needed
        run: |
          # Verificar e criar reposit√≥rio da aplica√ß√£o
          exists=$(aws ecr describe-repositories --repository-names ${{ secrets.ECR_REPOSITORY }} 2>/dev/null || echo "false")
          if [ "$exists" = "false" ]; then
            echo "Creating ECR repository ${{ secrets.ECR_REPOSITORY }}"
            aws ecr create-repository --repository-name ${{ secrets.ECR_REPOSITORY }} --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
          else
            echo "ECR repository ${{ secrets.ECR_REPOSITORY }} already exists"
          fi
          
          # Verificar e criar reposit√≥rio do banco de dados
          exists_db=$(aws ecr describe-repositories --repository-names ${{ secrets.ECR_REPOSITORY }}-db 2>/dev/null || echo "false")
          if [ "$exists_db" = "false" ]; then
            echo "Creating ECR repository ${{ secrets.ECR_REPOSITORY }}-db"
            aws ecr create-repository --repository-name ${{ secrets.ECR_REPOSITORY }}-db --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true
          else
            echo "ECR repository ${{ secrets.ECR_REPOSITORY }}-db already exists"
          fi

      - name: Create .env file for docker-compose build
        run: |
          echo "Criando arquivo .env para docker-compose build..."
          cat > .env << 'EOL'
          APP_IMAGE=backend-pointtils-dev
          DB_IMAGE=backend-pointtils-db-dev
          SPRING_DATASOURCE_URL=jdbc:postgresql://pointtils-db-dev:5432/postgres-dev
          SPRING_DATASOURCE_USERNAME=${{ secrets.SPRING_DATASOURCE_USERNAME }}
          SPRING_DATASOURCE_PASSWORD=${{ secrets.SPRING_DATASOURCE_PASSWORD }}
          SPRING_APPLICATION_NAME=${{ secrets.SPRING_APPLICATION_NAME }}
          SERVER_PORT=${{ vars.SERVER_PORT }}
          JWT_SECRET=${{ secrets.JWT_DEV_SECRET }}
          JWT_EXPIRATION_TIME=${{ vars.JWT_EXPIRATION_TIME }}
          JWT_REFRESH_EXPIRATION_TIME=${{ vars.JWT_REFRESH_EXPIRATION_TIME }}
          SPRING_JPA_HIBERNATE_DDL_AUTO=validate
          SPRING_JPA_SHOW_SQL=${{ vars.SPRING_JPA_SHOW_SQL }}
          SPRING_FLYWAY_ENABLED=true
          SPRING_FLYWAY_LOCATIONS=${{ vars.SPRING_FLYWAY_LOCATIONS }}
          SPRING_FLYWAY_BASELINE_ON_MIGRATE=true
          SPRING_FLYWAY_VALIDATE_ON_MIGRATE=true
          SPRINGDOC_API_DOCS_ENABLED=${{ vars.SPRINGDOC_API_DOCS_ENABLED }}
          SPRINGDOC_SWAGGER_UI_ENABLED=${{ vars.SPRINGDOC_SWAGGER_UI_ENABLED }}
          SPRINGDOC_SWAGGER_UI_PATH=/swagger-ui.html
          CLOUD_AWS_BUCKET_NAME=${{ secrets.CLOUD_AWS_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          POSTGRES_DB=${{ secrets.DB_NAME }}
          POSTGRES_USER=${{ secrets.DB_USERNAME }}
          POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
          EOL

      - name: Build and push images with docker compose
        id: build-images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: dev-${{ github.sha }}
        run: |
          # Construir imagens usando docker compose com vari√°veis do .env
          echo "Building images with docker compose using .env variables..."
          docker compose -f docker-compose-dev.yaml build --no-cache
          
          # Tag e push da imagem da aplica√ß√£o - usando ls para ver o nome correto das imagens
          echo "Listando imagens dispon√≠veis para debug:"
          docker images
          
          # Encontrar a imagem do aplicativo que acabamos de construir - usando o nome exato mostrado no output
          # Specify exact image names to ensure the correct images are tagged
          APP_IMAGE_NAME="${{ env.APP_IMAGE }}"
          DB_IMAGE_NAME="${{ env.DB_IMAGE }}"
          
          # Find the application image ID - using both exact name and wildcard approach
          APP_IMAGE_ID=$(docker images -q $APP_IMAGE_NAME 2>/dev/null || docker images -q "*${APP_IMAGE_NAME}*" 2>/dev/null || docker images | grep -E "$APP_IMAGE_NAME" | awk '{print $3}' | head -n1)
          echo "Nome da imagem da aplica√ß√£o: $APP_IMAGE_NAME"
          echo "ID da imagem da aplica√ß√£o: $APP_IMAGE_ID"
          
          # Verificar se a ID da imagem foi encontrada - n√£o usar fallback autom√°tico
          # para evitar mistura de imagens
          if [ -z "$APP_IMAGE_ID" ]; then
            echo "‚ö†Ô∏è ERRO: N√£o foi poss√≠vel encontrar ID da imagem da aplica√ß√£o!"
            echo "Listando todas as imagens dispon√≠veis:"
            docker images
            exit 1
          fi
          
          echo "Tagging and pushing application image..."
          # Verifica se temos tanto o ID quanto o nome da imagem para garantir tagging correto
          if [ -n "$APP_IMAGE_ID" ]; then
            echo "Usando ID da imagem para tagging: $APP_IMAGE_ID"
            # Use env.ECR_REPOSITORY (pointtils-dev) instead of secrets.ECR_REPOSITORY (pointtils)
            docker tag $APP_IMAGE_ID $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
            docker tag $APP_IMAGE_ID $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
            docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
            docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ env.APP_IMAGE_TAG }}
            echo "app_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è ERRO: N√£o foi poss√≠vel encontrar a imagem da aplica√ß√£o para tagging!"
            exit 1
          fi
          
          # Tag e push da imagem do banco de dados - encontrando ID da imagem
          # Using a more robust approach to find the database image
          DB_IMAGE_ID=$(docker images -q $DB_IMAGE_NAME 2>/dev/null || docker images -q "*${DB_IMAGE_NAME}*" 2>/dev/null || docker images | grep -E "$DB_IMAGE_NAME" | awk '{print $3}' | head -n1)
          echo "Nome da imagem do banco: $DB_IMAGE_NAME"
          echo "ID da imagem do banco: $DB_IMAGE_ID"
          
          # Verificar se a ID da imagem foi encontrada - n√£o usar fallback autom√°tico 
          # para evitar mistura de imagens
          if [ -z "$DB_IMAGE_ID" ]; then
            echo "‚ö†Ô∏è ERRO: N√£o foi poss√≠vel encontrar ID da imagem do banco de dados!"
            echo "Listando todas as imagens dispon√≠veis:"
            docker images
            exit 1
          fi
          
          echo "Tagging and pushing database image..."
          # Verifica se temos o ID da imagem para garantir tagging correto
          if [ -n "$DB_IMAGE_ID" ]; then
            echo "Usando ID da imagem de banco para tagging: $DB_IMAGE_ID"
            # Use env.ECR_REPOSITORY (pointtils-dev) instead of secrets.ECR_REPOSITORY (pointtils)
            docker tag $DB_IMAGE_ID $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
            docker tag $DB_IMAGE_ID $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
            docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG
            docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:${{ env.DB_IMAGE_TAG }}
            echo "db_image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}-db:$IMAGE_TAG" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è ERRO: N√£o foi poss√≠vel encontrar a imagem do banco de dados para tagging!"
            exit 1
          fi

  deploy-dev-infrastructure:
    name: Deploy Development Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.0'
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Create terraform.tfvars file for development
        run: |
          cat > terraform-dev/terraform.tfvars << 'EOF'
          aws_region     = "${{ secrets.AWS_REGION }}"
          db_username    = "${{ secrets.DB_USERNAME }}"
          db_password    = "${{ secrets.DB_PASSWORD }}"
          db_name        = "${{ secrets.DB_NAME }}"
          jwt_secret     = "${{ secrets.JWT_DEV_SECRET }}"
          app_image      = "${{ needs.build-and-test.outputs.app_image }}"
          db_image       = "${{ needs.build-and-test.outputs.db_image }}"
          EOF

      - name: Create Terraform backend resources
        run: |
          echo "Criando recursos de backend para Terraform..."
          chmod +x terraform-dev/create-backend.sh
          ./terraform-dev/create-backend.sh "${{ secrets.AWS_REGION }}"

      - name: Terraform Init (Development)
        working-directory: terraform-dev
        run: terraform init

      - name: Terraform Validate (Development)
        working-directory: terraform-dev
        run: terraform validate

      - name: Terraform Plan (Development)
        working-directory: terraform-dev
        run: terraform plan -out=tfplan

      - name: Terraform Apply (Development)
        working-directory: terraform-dev
        id: terraform-apply
        continue-on-error: true
        run: terraform apply -auto-approve tfplan

      - name: Save SSH private key from Terraform output
        working-directory: terraform-dev
        run: |
          echo "Salvando chave privada SSH do output do Terraform..."
          # Primeiro inicializar novamente para garantir que o estado esteja dispon√≠vel
          terraform init
          terraform output -raw private_key_pem > pointtils-dev-key.pem
          chmod 600 pointtils-dev-key.pem
          echo "Chave privada salva com permiss√µes corretas"
          echo "Verificando se a chave foi criada:"
          ls -la pointtils-dev-key.pem
          echo "Conte√∫do da chave (primeiras 1000 caracteres):"
          head -c 1000 pointtils-dev-key.pem

      - name: Upload SSH key as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ssh-key-dev
          path: terraform-dev/pointtils-dev-key.pem
          retention-days: 1

      - name: Get Terraform outputs (Development)
        working-directory: terraform-dev
        id: terraform-outputs
        run: |
          echo "=== Obtendo IP da inst√¢ncia EC2 de desenvolvimento ==="
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=pointtils-dev-app" --query 'Reservations[*].Instances[*].InstanceId' --output text)
          
          if [ -n "$INSTANCE_ID" ]; then
            echo "Instance ID encontrado: $INSTANCE_ID"
            
            # Buscar Elastic IP associado
            INSTANCE_IP=$(aws ec2 describe-addresses --filters "Name=instance-id,Values=$INSTANCE_ID" --query 'Addresses[0].PublicIp' --output text || echo "")
            
            # Se n√£o tem Elastic IP, usar o IP p√∫blico da inst√¢ncia
            if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
              echo "Elastic IP n√£o encontrado, usando IP p√∫blico direto da inst√¢ncia"
              INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text || echo "")
            fi
            
            # Limpar o IP (remover aspas e espa√ßos)
            CLEAN_IP=$(echo "$INSTANCE_IP" | tr -d '"' | tr -d ' ')
            echo "IP encontrado: $CLEAN_IP"
            
            # Verificar se o IP tem formato v√°lido
            if [[ "$CLEAN_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "IP v√°lido: $CLEAN_IP"
              echo "dev_app_ip=$CLEAN_IP" >> $GITHUB_OUTPUT
            else
              echo "AVISO: Formato de IP inv√°lido ($CLEAN_IP), usando placeholder"
              echo "dev_app_ip=127.0.0.1" >> $GITHUB_OUTPUT
            fi
          else
            echo "Nenhuma inst√¢ncia de desenvolvimento encontrada, usando IP placeholder"
            echo "dev_app_ip=127.0.0.1" >> $GITHUB_OUTPUT
          fi
          
          echo "dev_ecr_repo=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}" >> $GITHUB_OUTPUT

      - name: Verify EC2 host availability (Development)
        run: |
          HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
          
          if [ "$HOST_IP" = "127.0.0.1" ]; then
            echo "Usando IP placeholder (127.0.0.1), pulando verifica√ß√£o de SSH"
            echo "DEV_HOST_READY=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Verificando disponibilidade do host de desenvolvimento: $HOST_IP"
          # Instalar netcat se necess√°rio
          sudo apt-get update -y && sudo apt-get install -y netcat-openbsd
          # Aguardar um tempo para garantir que a inst√¢ncia esteja pronta
          echo "Aguardando 60 segundos para inicializa√ß√£o da inst√¢ncia de desenvolvimento..."
          sleep 60
          
          # Tentar conectar v√°rias vezes com um timeout
          for i in {1..12}; do
            if nc -z -v -w5 $HOST_IP 22; then
              echo "Host de desenvolvimento dispon√≠vel para SSH"
              echo "DEV_HOST_READY=true" >> $GITHUB_ENV
              break
            else
              echo "Tentativa $i: SSH ainda n√£o dispon√≠vel. Aguardando..."
              sleep 15
            fi
            
            if [ $i -eq 12 ]; then
              echo "AVISO: Host de desenvolvimento n√£o respondeu ap√≥s 12 tentativas, mas vamos continuar mesmo assim"
              echo "DEV_HOST_READY=false" >> $GITHUB_ENV
            fi
          done

      - name: Deploy latest images to Development EC2
        if: steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
        run: |
          HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
          echo "Executando deploy das imagens mais recentes na EC2 de desenvolvimento: $HOST_IP"
          
          # Copiar script de deploy para desenvolvimento
          echo "Copiando script de deploy para desenvolvimento..."
          scp -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils-dev-key.pem terraform-dev/deploy-dev-app.sh ubuntu@$HOST_IP:/home/ubuntu/
          
          # Executar script de deploy para desenvolvimento
          echo "Executando script de deploy para desenvolvimento..."
          ssh -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils-dev-key.pem ubuntu@$HOST_IP "chmod +x /home/ubuntu/deploy-dev-app.sh && /home/ubuntu/deploy-dev-app.sh \
            '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
            '${{ secrets.AWS_REGION }}'"
          
          echo "‚úÖ Deploy das imagens mais recentes para desenvolvimento conclu√≠do com sucesso!"

      - name: Health check development application
        if: steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
        run: |
          HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
          echo "Realizando health check final na aplica√ß√£o de desenvolvimento: http://$HOST_IP:8080/actuator/health"
          
          # Aguardar aplica√ß√£o inicializar ap√≥s deploy
          sleep 30
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$HOST_IP:8080/actuator/health || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Aplica√ß√£o de desenvolvimento respondendo corretamente (HTTP 200)"
              break
            else
              echo "Tentativa $i: Aplica√ß√£o de desenvolvimento n√£o respondeu (HTTP $RESPONSE). Aguardando..."
              sleep 15
            fi
          done

      - name: Rollback on failure (Development)
        if: failure() && steps.terraform-outputs.outputs.dev_app_ip != '127.0.0.1' && env.DEV_HOST_READY == 'true'
        run: |
          HOST_IP="${{ steps.terraform-outputs.outputs.dev_app_ip }}"
          echo "üö® Deploy de desenvolvimento falhou! Iniciando rollback autom√°tico..."
          
          # Copiar script de rollback para desenvolvimento
          scp -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils-dev-key.pem terraform-dev/rollback-dev-app.sh ubuntu@$HOST_IP:/home/ubuntu/
          
          # Executar rollback para desenvolvimento
          ssh -o StrictHostKeyChecking=no -i ./terraform-dev/pointtils-dev-key.pem ubuntu@$HOST_IP "chmod +x /home/ubuntu/rollback-dev-app.sh && /home/ubuntu/rollback-dev-app.sh \
            '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com' \
            '${{ secrets.AWS_REGION }}' \
            'previous'"
          
          echo "‚ö†Ô∏è Rollback de DESENVOLVIMENTO executado. Verifique o status da aplica√ß√£o de desenvolvimento manualmente."

      - name: Development Deployment Summary
        run: |
          echo "======================================"
          if [ "${{ env.DEV_HOST_READY }}" == "true" ]; then
            echo "‚úÖ Development deployment completed successfully!"
          elif [ "${{ steps.terraform-outputs.outputs.dev_app_ip }}" == "127.0.0.1" ]; then
            echo "‚ö†Ô∏è Development infrastructure deployment incomplete - could not retrieve valid IP"
          else
            echo "‚ö†Ô∏è Development deployment may have issues - host was not ready for SSH"
          fi
          echo "======================================"
          
          if [ "${{ steps.terraform-outputs.outputs.dev_app_ip }}" != "127.0.0.1" ]; then
            echo "Development Application URL: http://${{ steps.terraform-outputs.outputs.dev_app_ip }}:8080"
            echo "Development Swagger UI: http://${{ steps.terraform-outputs.outputs.dev_app_ip }}:8080/swagger-ui.html"
            echo "Development SSH Access: ssh ubuntu@${{ steps.terraform-outputs.outputs.dev_app_ip }}"
          else
            echo "Development Application URL: Not available (deployment incomplete)"
            echo "Development SSH Access: Not available (deployment incomplete)"
          fi
          
          echo "Development ECR Repository: ${{ steps.terraform-outputs.outputs.dev_ecr_repo }}"
          echo "======================================"
